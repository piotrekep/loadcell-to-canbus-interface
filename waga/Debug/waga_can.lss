
waga_can.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000008cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000858  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000019  00800100  00800100  000008cc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000008cc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000008fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  0000093c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000019ea  00000000  00000000  00000ae4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b42  00000000  00000000  000024ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f65  00000000  00000000  00003010  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004c0  00000000  00000000  00003f78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000006b2  00000000  00000000  00004438  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000121d  00000000  00000000  00004aea  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  00005d07  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
   8:	0c 94 2a 03 	jmp	0x654	; 0x654 <__vector_2>
   c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  10:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  14:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  18:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  1c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  20:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  24:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  28:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  2c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  30:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  34:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  38:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__vector_14>
  3c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  40:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  44:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  48:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  4c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  50:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  54:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  58:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  5c:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  60:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  64:	0c 94 4d 00 	jmp	0x9a	; 0x9a <__bad_interrupt>
  68:	47 03       	mulsu	r20, r23
  6a:	4b 03       	fmul	r20, r19
  6c:	4f 03       	fmul	r20, r23
  6e:	53 03       	mulsu	r21, r19
  70:	57 03       	mulsu	r21, r23
  72:	5b 03       	fmul	r21, r19
  74:	5f 03       	fmul	r21, r23

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf ef       	ldi	r28, 0xFF	; 255
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61

00000082 <__do_clear_bss>:
  82:	21 e0       	ldi	r18, 0x01	; 1
  84:	a0 e0       	ldi	r26, 0x00	; 0
  86:	b1 e0       	ldi	r27, 0x01	; 1
  88:	01 c0       	rjmp	.+2      	; 0x8c <.do_clear_bss_start>

0000008a <.do_clear_bss_loop>:
  8a:	1d 92       	st	X+, r1

0000008c <.do_clear_bss_start>:
  8c:	a9 31       	cpi	r26, 0x19	; 25
  8e:	b2 07       	cpc	r27, r18
  90:	e1 f7       	brne	.-8      	; 0x8a <.do_clear_bss_loop>
  92:	0e 94 57 02 	call	0x4ae	; 0x4ae <main>
  96:	0c 94 2a 04 	jmp	0x854	; 0x854 <_exit>

0000009a <__bad_interrupt>:
  9a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000009e <ADS1234_init>:
#include <inttypes.h>


void ADS1234_init(void)
{
	GAIN0_DDR |= (1<<GAIN0_PIN);
  9e:	51 9a       	sbi	0x0a, 1	; 10
	GAIN1_DDR |= (1<<GAIN1_PIN);
  a0:	52 9a       	sbi	0x0a, 2	; 10
	
	A0_DDR |= (1<<A0_PIN);
  a2:	39 9a       	sbi	0x07, 1	; 7
	A1_DDR |= (1<<A1_PIN);
  a4:	38 9a       	sbi	0x07, 0	; 7
	
	SPEED_DDR |= (1<<SPEED_PIN);
  a6:	3d 9a       	sbi	0x07, 5	; 7
	
	DATA_DDR &= ~(1<<DATA_PIN);
  a8:	3a 98       	cbi	0x07, 2	; 7
	CLK_DDR |= (1<<CLK_PIN);
  aa:	3b 9a       	sbi	0x07, 3	; 7
	
	PWR_DDR |=(1<<PWR_PIN);
  ac:	3c 9a       	sbi	0x07, 4	; 7
  ae:	08 95       	ret

000000b0 <ADS1234_PWR>:


void ADS1234_PWR(uint8_t stat)
{

switch(stat)
  b0:	88 23       	and	r24, r24
  b2:	19 f0       	breq	.+6      	; 0xba <ADS1234_PWR+0xa>
  b4:	81 30       	cpi	r24, 0x01	; 1
  b6:	19 f0       	breq	.+6      	; 0xbe <ADS1234_PWR+0xe>
  b8:	08 95       	ret
 {
	case 0: 
		PWR_PORT &= ~(1<<PWR_PIN);
  ba:	44 98       	cbi	0x08, 4	; 8
		break;
  bc:	08 95       	ret
	case 1:
		PWR_PORT |= (1<<PWR_PIN);
  be:	44 9a       	sbi	0x08, 4	; 8
  c0:	08 95       	ret

000000c2 <ADS1234_input_select>:
}

void ADS1234_input_select(uint8_t input)
{

	switch(input)
  c2:	81 30       	cpi	r24, 0x01	; 1
  c4:	49 f0       	breq	.+18     	; 0xd8 <ADS1234_input_select+0x16>
  c6:	28 f0       	brcs	.+10     	; 0xd2 <ADS1234_input_select+0x10>
  c8:	82 30       	cpi	r24, 0x02	; 2
  ca:	49 f0       	breq	.+18     	; 0xde <ADS1234_input_select+0x1c>
  cc:	83 30       	cpi	r24, 0x03	; 3
  ce:	51 f0       	breq	.+20     	; 0xe4 <ADS1234_input_select+0x22>
  d0:	08 95       	ret
	{
		case 0:
			A0_PORT &= ~(1<<A0_PIN);
  d2:	41 98       	cbi	0x08, 1	; 8
			A1_PORT &= ~(1<<A1_PIN);
  d4:	40 98       	cbi	0x08, 0	; 8
			break;
  d6:	08 95       	ret
		case 1:
			A0_PORT &= ~(1<<A0_PIN);
  d8:	41 98       	cbi	0x08, 1	; 8
			A1_PORT |= (1<<A1_PIN);
  da:	40 9a       	sbi	0x08, 0	; 8
			break;
  dc:	08 95       	ret
		case 2:
			A0_PORT |= (1<<A0_PIN);
  de:	41 9a       	sbi	0x08, 1	; 8
			A1_PORT &= ~(1<<A1_PIN);
  e0:	40 98       	cbi	0x08, 0	; 8
			break;
  e2:	08 95       	ret
		case 3:
			A0_PORT |= (1<<A0_PIN);
  e4:	41 9a       	sbi	0x08, 1	; 8
			A1_PORT |= (1<<A1_PIN);;
  e6:	40 9a       	sbi	0x08, 0	; 8
  e8:	08 95       	ret

000000ea <ADS1234_gain_select>:
}

void ADS1234_gain_select(uint8_t gain)
{

	switch(gain)
  ea:	81 30       	cpi	r24, 0x01	; 1
  ec:	49 f0       	breq	.+18     	; 0x100 <ADS1234_gain_select+0x16>
  ee:	28 f0       	brcs	.+10     	; 0xfa <ADS1234_gain_select+0x10>
  f0:	82 30       	cpi	r24, 0x02	; 2
  f2:	49 f0       	breq	.+18     	; 0x106 <ADS1234_gain_select+0x1c>
  f4:	83 30       	cpi	r24, 0x03	; 3
  f6:	51 f0       	breq	.+20     	; 0x10c <ADS1234_gain_select+0x22>
  f8:	08 95       	ret
	{
		case 0:
		GAIN0_PORT &= ~(1<<GAIN0_PIN);
  fa:	59 98       	cbi	0x0b, 1	; 11
		GAIN1_PORT &= ~(1<<GAIN1_PIN);
  fc:	5a 98       	cbi	0x0b, 2	; 11
		break;
  fe:	08 95       	ret
		case 1:
		GAIN0_PORT &= ~(1<<GAIN0_PIN);
 100:	59 98       	cbi	0x0b, 1	; 11
		GAIN1_PORT |= (1<<GAIN1_PIN);
 102:	5a 9a       	sbi	0x0b, 2	; 11
		break;
 104:	08 95       	ret
		case 2:
		GAIN0_PORT |= (1<<GAIN0_PIN);
 106:	59 9a       	sbi	0x0b, 1	; 11
		GAIN1_PORT &= ~(1<<GAIN1_PIN);
 108:	5a 98       	cbi	0x0b, 2	; 11
		break;
 10a:	08 95       	ret
		case 3:
		GAIN0_PORT |= (1<<GAIN0_PIN);
 10c:	59 9a       	sbi	0x0b, 1	; 11
		GAIN1_PORT |= (1<<GAIN1_PIN);;
 10e:	5a 9a       	sbi	0x0b, 2	; 11
 110:	08 95       	ret

00000112 <ADS1234_Speed>:


void ADS1234_Speed(uint8_t spd)
{

	switch(spd)
 112:	88 23       	and	r24, r24
 114:	19 f0       	breq	.+6      	; 0x11c <ADS1234_Speed+0xa>
 116:	81 30       	cpi	r24, 0x01	; 1
 118:	19 f0       	breq	.+6      	; 0x120 <ADS1234_Speed+0xe>
 11a:	08 95       	ret
	{
		case 0:
		SPEED_PORT &= ~(1<<SPEED_PIN);
 11c:	45 98       	cbi	0x08, 5	; 8
		break;
 11e:	08 95       	ret
		case 1:
		SPEED_PORT |= (1<<SPEED_PIN);
 120:	45 9a       	sbi	0x08, 5	; 8
 122:	08 95       	ret

00000124 <ADS1234_clk_high>:
}


void ADS1234_clk_high(void)
{
	CLK_PORT |= (1<<CLK_PIN);
 124:	43 9a       	sbi	0x08, 3	; 8
 126:	08 95       	ret

00000128 <ADS1234_clk_low>:
	
}

void ADS1234_clk_low(void)
{
	CLK_PORT &= ~(1<<CLK_PIN);
 128:	43 98       	cbi	0x08, 3	; 8
 12a:	08 95       	ret

0000012c <ADS1234_read>:
		break;
	}
}

uint32_t ADS1234_read(void)
{
 12c:	cf 92       	push	r12
 12e:	df 92       	push	r13
 130:	ef 92       	push	r14
 132:	ff 92       	push	r15
 134:	0f 93       	push	r16
 136:	1f 93       	push	r17
 138:	cf 93       	push	r28
 13a:	df 93       	push	r29
 13c:	c7 e0       	ldi	r28, 0x07	; 7
 13e:	d0 e0       	ldi	r29, 0x00	; 0
	
	uint8_t x = 0;
 140:	00 e0       	ldi	r16, 0x00	; 0
	uint8_t z = 0;
	uint32_t r;
	for(uint8_t i =8; i>0; i--)
	{
		ADS1234_clk_high();
		if (DATA_PORT & (1<<DATA_PIN)) x |= 1 << (i-1);
 142:	ee 24       	eor	r14, r14
 144:	e3 94       	inc	r14
 146:	f1 2c       	mov	r15, r1
	uint8_t y = 0;
	uint8_t z = 0;
	uint32_t r;
	for(uint8_t i =8; i>0; i--)
	{
		ADS1234_clk_high();
 148:	0e 94 92 00 	call	0x124	; 0x124 <ADS1234_clk_high>
		if (DATA_PORT & (1<<DATA_PIN)) x |= 1 << (i-1);
 14c:	32 9b       	sbis	0x06, 2	; 6
 14e:	08 c0       	rjmp	.+16     	; 0x160 <ADS1234_read+0x34>
 150:	c7 01       	movw	r24, r14
 152:	0c 2e       	mov	r0, r28
 154:	02 c0       	rjmp	.+4      	; 0x15a <ADS1234_read+0x2e>
 156:	88 0f       	add	r24, r24
 158:	99 1f       	adc	r25, r25
 15a:	0a 94       	dec	r0
 15c:	e2 f7       	brpl	.-8      	; 0x156 <ADS1234_read+0x2a>
 15e:	08 2b       	or	r16, r24
		ADS1234_clk_low();
 160:	0e 94 94 00 	call	0x128	; 0x128 <ADS1234_clk_low>
 164:	21 97       	sbiw	r28, 0x01	; 1
 166:	80 f7       	brcc	.-32     	; 0x148 <ADS1234_read+0x1c>
 168:	c7 e0       	ldi	r28, 0x07	; 7
 16a:	d0 e0       	ldi	r29, 0x00	; 0
 16c:	10 e0       	ldi	r17, 0x00	; 0
	}
	
	for(uint8_t i =8; i>0; i--)
	{
		ADS1234_clk_high();
		if (DATA_PORT & (1<<DATA_PIN)) y |= 1 << (i-1);
 16e:	ee 24       	eor	r14, r14
 170:	e3 94       	inc	r14
 172:	f1 2c       	mov	r15, r1
		
	}
	
	for(uint8_t i =8; i>0; i--)
	{
		ADS1234_clk_high();
 174:	0e 94 92 00 	call	0x124	; 0x124 <ADS1234_clk_high>
		if (DATA_PORT & (1<<DATA_PIN)) y |= 1 << (i-1);
 178:	32 9b       	sbis	0x06, 2	; 6
 17a:	08 c0       	rjmp	.+16     	; 0x18c <ADS1234_read+0x60>
 17c:	c7 01       	movw	r24, r14
 17e:	0c 2e       	mov	r0, r28
 180:	02 c0       	rjmp	.+4      	; 0x186 <ADS1234_read+0x5a>
 182:	88 0f       	add	r24, r24
 184:	99 1f       	adc	r25, r25
 186:	0a 94       	dec	r0
 188:	e2 f7       	brpl	.-8      	; 0x182 <ADS1234_read+0x56>
 18a:	18 2b       	or	r17, r24
		ADS1234_clk_low();
 18c:	0e 94 94 00 	call	0x128	; 0x128 <ADS1234_clk_low>
 190:	21 97       	sbiw	r28, 0x01	; 1
 192:	80 f7       	brcc	.-32     	; 0x174 <ADS1234_read+0x48>
 194:	c7 e0       	ldi	r28, 0x07	; 7
 196:	d0 e0       	ldi	r29, 0x00	; 0
 198:	f1 2c       	mov	r15, r1
	}
	
	for(uint8_t i =8; i>0; i--)
	{
		ADS1234_clk_high();
		if (DATA_PORT & (1<<DATA_PIN)) z |= 1 << (i-1);
 19a:	cc 24       	eor	r12, r12
 19c:	c3 94       	inc	r12
 19e:	d1 2c       	mov	r13, r1
		
	}
	
	for(uint8_t i =8; i>0; i--)
	{
		ADS1234_clk_high();
 1a0:	0e 94 92 00 	call	0x124	; 0x124 <ADS1234_clk_high>
		if (DATA_PORT & (1<<DATA_PIN)) z |= 1 << (i-1);
 1a4:	32 9b       	sbis	0x06, 2	; 6
 1a6:	08 c0       	rjmp	.+16     	; 0x1b8 <ADS1234_read+0x8c>
 1a8:	c6 01       	movw	r24, r12
 1aa:	0c 2e       	mov	r0, r28
 1ac:	02 c0       	rjmp	.+4      	; 0x1b2 <ADS1234_read+0x86>
 1ae:	88 0f       	add	r24, r24
 1b0:	99 1f       	adc	r25, r25
 1b2:	0a 94       	dec	r0
 1b4:	e2 f7       	brpl	.-8      	; 0x1ae <ADS1234_read+0x82>
 1b6:	f8 2a       	or	r15, r24
		ADS1234_clk_low();
 1b8:	0e 94 94 00 	call	0x128	; 0x128 <ADS1234_clk_low>
 1bc:	21 97       	sbiw	r28, 0x01	; 1
 1be:	80 f7       	brcc	.-32     	; 0x1a0 <ADS1234_read+0x74>
		
	}
	
	ADS1234_clk_high();
 1c0:	0e 94 92 00 	call	0x124	; 0x124 <ADS1234_clk_high>
	ADS1234_clk_low();
 1c4:	0e 94 94 00 	call	0x128	; 0x128 <ADS1234_clk_low>



	r=x;
	r=(r<<8)|y;
 1c8:	81 2f       	mov	r24, r17
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	a0 e0       	ldi	r26, 0x00	; 0
 1ce:	b0 e0       	ldi	r27, 0x00	; 0
	r=(r<<8)|z;
 1d0:	90 2b       	or	r25, r16
 1d2:	ba 2f       	mov	r27, r26
 1d4:	a9 2f       	mov	r26, r25
 1d6:	98 2f       	mov	r25, r24
 1d8:	88 27       	eor	r24, r24

	return r;
 1da:	bc 01       	movw	r22, r24
 1dc:	cd 01       	movw	r24, r26
 1de:	6f 29       	or	r22, r15
	
}
 1e0:	df 91       	pop	r29
 1e2:	cf 91       	pop	r28
 1e4:	1f 91       	pop	r17
 1e6:	0f 91       	pop	r16
 1e8:	ff 90       	pop	r15
 1ea:	ef 90       	pop	r14
 1ec:	df 90       	pop	r13
 1ee:	cf 90       	pop	r12
 1f0:	08 95       	ret

000001f2 <CAN_reset>:
//reads interupts flags
uint8_t CAN_get_intf(void)
{
	return CAN_Read_single(0x2C);
	
}
 1f2:	0e 94 20 04 	call	0x840	; 0x840 <SPI_setCS>
 1f6:	80 ec       	ldi	r24, 0xC0	; 192
 1f8:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 1fc:	0e 94 22 04 	call	0x844	; 0x844 <SPI_clearCS>
 200:	08 95       	ret

00000202 <CAN_Read_single>:
 202:	cf 93       	push	r28
 204:	c8 2f       	mov	r28, r24
 206:	0e 94 20 04 	call	0x840	; 0x840 <SPI_setCS>
 20a:	83 e0       	ldi	r24, 0x03	; 3
 20c:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 210:	8c 2f       	mov	r24, r28
 212:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 216:	0e 94 19 04 	call	0x832	; 0x832 <SPI_MasterRecieve>
 21a:	c8 2f       	mov	r28, r24
 21c:	0e 94 22 04 	call	0x844	; 0x844 <SPI_clearCS>
 220:	8c 2f       	mov	r24, r28
 222:	cf 91       	pop	r28
 224:	08 95       	ret

00000226 <CAN_Write>:
 226:	ef 92       	push	r14
 228:	ff 92       	push	r15
 22a:	0f 93       	push	r16
 22c:	1f 93       	push	r17
 22e:	cf 93       	push	r28
 230:	df 93       	push	r29
 232:	c8 2f       	mov	r28, r24
 234:	16 2f       	mov	r17, r22
 236:	7a 01       	movw	r14, r20
 238:	0e 94 20 04 	call	0x840	; 0x840 <SPI_setCS>
 23c:	82 e0       	ldi	r24, 0x02	; 2
 23e:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 242:	8c 2f       	mov	r24, r28
 244:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 248:	11 23       	and	r17, r17
 24a:	71 f0       	breq	.+28     	; 0x268 <CAN_Write+0x42>
 24c:	e7 01       	movw	r28, r14
 24e:	11 50       	subi	r17, 0x01	; 1
 250:	01 2f       	mov	r16, r17
 252:	10 e0       	ldi	r17, 0x00	; 0
 254:	0f 5f       	subi	r16, 0xFF	; 255
 256:	1f 4f       	sbci	r17, 0xFF	; 255
 258:	0e 0d       	add	r16, r14
 25a:	1f 1d       	adc	r17, r15
 25c:	89 91       	ld	r24, Y+
 25e:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 262:	c0 17       	cp	r28, r16
 264:	d1 07       	cpc	r29, r17
 266:	d1 f7       	brne	.-12     	; 0x25c <CAN_Write+0x36>
 268:	0e 94 22 04 	call	0x844	; 0x844 <SPI_clearCS>
 26c:	df 91       	pop	r29
 26e:	cf 91       	pop	r28
 270:	1f 91       	pop	r17
 272:	0f 91       	pop	r16
 274:	ff 90       	pop	r15
 276:	ef 90       	pop	r14
 278:	08 95       	ret

0000027a <CAN_Write_single>:
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
 27e:	d8 2f       	mov	r29, r24
 280:	c6 2f       	mov	r28, r22
 282:	0e 94 20 04 	call	0x840	; 0x840 <SPI_setCS>
 286:	82 e0       	ldi	r24, 0x02	; 2
 288:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 28c:	8d 2f       	mov	r24, r29
 28e:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 292:	8c 2f       	mov	r24, r28
 294:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 298:	0e 94 22 04 	call	0x844	; 0x844 <SPI_clearCS>
 29c:	df 91       	pop	r29
 29e:	cf 91       	pop	r28
 2a0:	08 95       	ret

000002a2 <CAN_modify>:
 2a2:	1f 93       	push	r17
 2a4:	cf 93       	push	r28
 2a6:	df 93       	push	r29
 2a8:	18 2f       	mov	r17, r24
 2aa:	d6 2f       	mov	r29, r22
 2ac:	c4 2f       	mov	r28, r20
 2ae:	0e 94 20 04 	call	0x840	; 0x840 <SPI_setCS>
 2b2:	85 e0       	ldi	r24, 0x05	; 5
 2b4:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 2b8:	81 2f       	mov	r24, r17
 2ba:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 2be:	8d 2f       	mov	r24, r29
 2c0:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 2c4:	8c 2f       	mov	r24, r28
 2c6:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 2ca:	0e 94 22 04 	call	0x844	; 0x844 <SPI_clearCS>
 2ce:	df 91       	pop	r29
 2d0:	cf 91       	pop	r28
 2d2:	1f 91       	pop	r17
 2d4:	08 95       	ret

000002d6 <CAN_mode>:
 2d6:	82 30       	cpi	r24, 0x02	; 2
 2d8:	a9 f0       	breq	.+42     	; 0x304 <CAN_mode+0x2e>
 2da:	28 f4       	brcc	.+10     	; 0x2e6 <CAN_mode+0x10>
 2dc:	88 23       	and	r24, r24
 2de:	41 f0       	breq	.+16     	; 0x2f0 <CAN_mode+0x1a>
 2e0:	81 30       	cpi	r24, 0x01	; 1
 2e2:	59 f0       	breq	.+22     	; 0x2fa <CAN_mode+0x24>
 2e4:	08 95       	ret
 2e6:	83 30       	cpi	r24, 0x03	; 3
 2e8:	91 f0       	breq	.+36     	; 0x30e <CAN_mode+0x38>
 2ea:	84 30       	cpi	r24, 0x04	; 4
 2ec:	a9 f0       	breq	.+42     	; 0x318 <CAN_mode+0x42>
 2ee:	08 95       	ret
 2f0:	60 e0       	ldi	r22, 0x00	; 0
 2f2:	8f e0       	ldi	r24, 0x0F	; 15
 2f4:	0e 94 3d 01 	call	0x27a	; 0x27a <CAN_Write_single>
 2f8:	08 95       	ret
 2fa:	60 e2       	ldi	r22, 0x20	; 32
 2fc:	8f e0       	ldi	r24, 0x0F	; 15
 2fe:	0e 94 3d 01 	call	0x27a	; 0x27a <CAN_Write_single>
 302:	08 95       	ret
 304:	60 e4       	ldi	r22, 0x40	; 64
 306:	8f e0       	ldi	r24, 0x0F	; 15
 308:	0e 94 3d 01 	call	0x27a	; 0x27a <CAN_Write_single>
 30c:	08 95       	ret
 30e:	60 e6       	ldi	r22, 0x60	; 96
 310:	8f e0       	ldi	r24, 0x0F	; 15
 312:	0e 94 3d 01 	call	0x27a	; 0x27a <CAN_Write_single>
 316:	08 95       	ret
 318:	60 e8       	ldi	r22, 0x80	; 128
 31a:	8f e0       	ldi	r24, 0x0F	; 15
 31c:	0e 94 3d 01 	call	0x27a	; 0x27a <CAN_Write_single>
 320:	08 95       	ret

00000322 <CAN_check_mode>:
 322:	8e e0       	ldi	r24, 0x0E	; 14
 324:	0e 94 01 01 	call	0x202	; 0x202 <CAN_Read_single>
 328:	80 7e       	andi	r24, 0xE0	; 224
 32a:	80 34       	cpi	r24, 0x40	; 64
 32c:	69 f0       	breq	.+26     	; 0x348 <CAN_check_mode+0x26>
 32e:	28 f4       	brcc	.+10     	; 0x33a <CAN_check_mode+0x18>
 330:	88 23       	and	r24, r24
 332:	91 f0       	breq	.+36     	; 0x358 <CAN_check_mode+0x36>
 334:	80 32       	cpi	r24, 0x20	; 32
 336:	31 f0       	breq	.+12     	; 0x344 <CAN_check_mode+0x22>
 338:	0d c0       	rjmp	.+26     	; 0x354 <CAN_check_mode+0x32>
 33a:	80 36       	cpi	r24, 0x60	; 96
 33c:	39 f0       	breq	.+14     	; 0x34c <CAN_check_mode+0x2a>
 33e:	80 38       	cpi	r24, 0x80	; 128
 340:	39 f0       	breq	.+14     	; 0x350 <CAN_check_mode+0x2e>
 342:	08 c0       	rjmp	.+16     	; 0x354 <CAN_check_mode+0x32>
 344:	81 e0       	ldi	r24, 0x01	; 1
 346:	08 95       	ret
 348:	82 e0       	ldi	r24, 0x02	; 2
 34a:	08 95       	ret
 34c:	83 e0       	ldi	r24, 0x03	; 3
 34e:	08 95       	ret
 350:	84 e0       	ldi	r24, 0x04	; 4
 352:	08 95       	ret
 354:	8f ef       	ldi	r24, 0xFF	; 255
 356:	08 95       	ret
 358:	80 e0       	ldi	r24, 0x00	; 0
 35a:	08 95       	ret

0000035c <CAN_setBaud20>:
 35c:	cf 93       	push	r28
 35e:	df 93       	push	r29
 360:	00 d0       	rcall	.+0      	; 0x362 <CAN_setBaud20+0x6>
 362:	1f 92       	push	r1
 364:	cd b7       	in	r28, 0x3d	; 61
 366:	de b7       	in	r29, 0x3e	; 62
 368:	81 30       	cpi	r24, 0x01	; 1
 36a:	59 f0       	breq	.+22     	; 0x382 <CAN_setBaud20+0x26>
 36c:	18 f0       	brcs	.+6      	; 0x374 <CAN_setBaud20+0x18>
 36e:	82 30       	cpi	r24, 0x02	; 2
 370:	79 f0       	breq	.+30     	; 0x390 <CAN_setBaud20+0x34>
 372:	13 c0       	rjmp	.+38     	; 0x39a <CAN_setBaud20+0x3e>
 374:	87 e0       	ldi	r24, 0x07	; 7
 376:	89 83       	std	Y+1, r24	; 0x01
 378:	8a eb       	ldi	r24, 0xBA	; 186
 37a:	8a 83       	std	Y+2, r24	; 0x02
 37c:	83 e0       	ldi	r24, 0x03	; 3
 37e:	8b 83       	std	Y+3, r24	; 0x03
 380:	0c c0       	rjmp	.+24     	; 0x39a <CAN_setBaud20+0x3e>
 382:	87 e0       	ldi	r24, 0x07	; 7
 384:	89 83       	std	Y+1, r24	; 0x01
 386:	8a eb       	ldi	r24, 0xBA	; 186
 388:	8a 83       	std	Y+2, r24	; 0x02
 38a:	81 e0       	ldi	r24, 0x01	; 1
 38c:	8b 83       	std	Y+3, r24	; 0x03
 38e:	05 c0       	rjmp	.+10     	; 0x39a <CAN_setBaud20+0x3e>
 390:	87 e0       	ldi	r24, 0x07	; 7
 392:	89 83       	std	Y+1, r24	; 0x01
 394:	8a eb       	ldi	r24, 0xBA	; 186
 396:	8a 83       	std	Y+2, r24	; 0x02
 398:	1b 82       	std	Y+3, r1	; 0x03
 39a:	ae 01       	movw	r20, r28
 39c:	4f 5f       	subi	r20, 0xFF	; 255
 39e:	5f 4f       	sbci	r21, 0xFF	; 255
 3a0:	63 e0       	ldi	r22, 0x03	; 3
 3a2:	88 e2       	ldi	r24, 0x28	; 40
 3a4:	0e 94 13 01 	call	0x226	; 0x226 <CAN_Write>
 3a8:	0f 90       	pop	r0
 3aa:	0f 90       	pop	r0
 3ac:	0f 90       	pop	r0
 3ae:	df 91       	pop	r29
 3b0:	cf 91       	pop	r28
 3b2:	08 95       	ret

000003b4 <CAN_TX_Write>:
 3b4:	ef 92       	push	r14
 3b6:	0f 93       	push	r16
 3b8:	1f 93       	push	r17
 3ba:	cf 93       	push	r28
 3bc:	df 93       	push	r29
 3be:	cd b7       	in	r28, 0x3d	; 61
 3c0:	de b7       	in	r29, 0x3e	; 62
 3c2:	67 97       	sbiw	r28, 0x17	; 23
 3c4:	0f b6       	in	r0, 0x3f	; 63
 3c6:	f8 94       	cli
 3c8:	de bf       	out	0x3e, r29	; 62
 3ca:	0f be       	out	0x3f, r0	; 63
 3cc:	cd bf       	out	0x3d, r28	; 61
 3ce:	0e 87       	std	Y+14, r16	; 0x0e
 3d0:	1f 87       	std	Y+15, r17	; 0x0f
 3d2:	28 8b       	std	Y+16, r18	; 0x10
 3d4:	39 8b       	std	Y+17, r19	; 0x11
 3d6:	4a 8b       	std	Y+18, r20	; 0x12
 3d8:	5b 8b       	std	Y+19, r21	; 0x13
 3da:	6c 8b       	std	Y+20, r22	; 0x14
 3dc:	7d 8b       	std	Y+21, r23	; 0x15
 3de:	8e 8b       	std	Y+22, r24	; 0x16
 3e0:	9f 8b       	std	Y+23, r25	; 0x17
 3e2:	20 2f       	mov	r18, r16
 3e4:	31 2f       	mov	r19, r17
 3e6:	37 70       	andi	r19, 0x07	; 7
 3e8:	8e 2d       	mov	r24, r14
 3ea:	82 95       	swap	r24
 3ec:	80 7f       	andi	r24, 0xF0	; 240
 3ee:	8f 5c       	subi	r24, 0xCF	; 207
 3f0:	a9 01       	movw	r20, r18
 3f2:	55 95       	asr	r21
 3f4:	47 95       	ror	r20
 3f6:	55 95       	asr	r21
 3f8:	47 95       	ror	r20
 3fa:	55 95       	asr	r21
 3fc:	47 95       	ror	r20
 3fe:	49 83       	std	Y+1, r20	; 0x01
 400:	22 95       	swap	r18
 402:	22 0f       	add	r18, r18
 404:	20 7e       	andi	r18, 0xE0	; 224
 406:	2a 83       	std	Y+2, r18	; 0x02
 408:	1b 82       	std	Y+3, r1	; 0x03
 40a:	1c 82       	std	Y+4, r1	; 0x04
 40c:	13 fb       	bst	r17, 3
 40e:	99 27       	eor	r25, r25
 410:	90 f9       	bld	r25, 0
 412:	12 95       	swap	r17
 414:	1f 70       	andi	r17, 0x0F	; 15
 416:	20 e4       	ldi	r18, 0x40	; 64
 418:	92 9f       	mul	r25, r18
 41a:	10 0d       	add	r17, r0
 41c:	11 24       	eor	r1, r1
 41e:	1d 83       	std	Y+5, r17	; 0x05
 420:	fe 01       	movw	r30, r28
 422:	70 96       	adiw	r30, 0x10	; 16
 424:	de 01       	movw	r26, r28
 426:	16 96       	adiw	r26, 0x06	; 6
 428:	9e 01       	movw	r18, r28
 42a:	28 5e       	subi	r18, 0xE8	; 232
 42c:	3f 4f       	sbci	r19, 0xFF	; 255
 42e:	91 91       	ld	r25, Z+
 430:	9d 93       	st	X+, r25
 432:	e2 17       	cp	r30, r18
 434:	f3 07       	cpc	r31, r19
 436:	d9 f7       	brne	.-10     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
 438:	ae 01       	movw	r20, r28
 43a:	4f 5f       	subi	r20, 0xFF	; 255
 43c:	5f 4f       	sbci	r21, 0xFF	; 255
 43e:	6d e0       	ldi	r22, 0x0D	; 13
 440:	0e 94 13 01 	call	0x226	; 0x226 <CAN_Write>
 444:	67 96       	adiw	r28, 0x17	; 23
 446:	0f b6       	in	r0, 0x3f	; 63
 448:	f8 94       	cli
 44a:	de bf       	out	0x3e, r29	; 62
 44c:	0f be       	out	0x3f, r0	; 63
 44e:	cd bf       	out	0x3d, r28	; 61
 450:	df 91       	pop	r29
 452:	cf 91       	pop	r28
 454:	1f 91       	pop	r17
 456:	0f 91       	pop	r16
 458:	ef 90       	pop	r14
 45a:	08 95       	ret

0000045c <CAN_RTS>:
 45c:	cf 93       	push	r28
 45e:	c8 2f       	mov	r28, r24
 460:	0e 94 20 04 	call	0x840	; 0x840 <SPI_setCS>
 464:	81 e0       	ldi	r24, 0x01	; 1
 466:	90 e0       	ldi	r25, 0x00	; 0
 468:	02 c0       	rjmp	.+4      	; 0x46e <CAN_RTS+0x12>
 46a:	88 0f       	add	r24, r24
 46c:	99 1f       	adc	r25, r25
 46e:	ca 95       	dec	r28
 470:	e2 f7       	brpl	.-8      	; 0x46a <CAN_RTS+0xe>
 472:	80 58       	subi	r24, 0x80	; 128
 474:	0e 94 14 04 	call	0x828	; 0x828 <SPI_MasterTransmit>
 478:	0e 94 22 04 	call	0x844	; 0x844 <SPI_clearCS>
 47c:	cf 91       	pop	r28
 47e:	08 95       	ret

00000480 <CAN_int_en>:
 480:	68 2f       	mov	r22, r24
 482:	8b e2       	ldi	r24, 0x2B	; 43
 484:	0e 94 3d 01 	call	0x27a	; 0x27a <CAN_Write_single>
 488:	08 95       	ret

0000048a <CAN_get_pint>:
//gets pending interrupt
uint8_t CAN_get_pint(void)
{
	return (CAN_Read_single(0x0E)>>1) & ~0xF8;
 48a:	8e e0       	ldi	r24, 0x0E	; 14
 48c:	0e 94 01 01 	call	0x202	; 0x202 <CAN_Read_single>
 490:	86 95       	lsr	r24
}
 492:	87 70       	andi	r24, 0x07	; 7
 494:	08 95       	ret

00000496 <CAN_clear_int>:
//numbers 0 to 7 look above
void CAN_clear_int(uint8_t flag)
{
	uint8_t mask;
	mask=1<<flag;
	CAN_modify(0x2c,mask,0x00);
 496:	61 e0       	ldi	r22, 0x01	; 1
 498:	70 e0       	ldi	r23, 0x00	; 0
 49a:	02 c0       	rjmp	.+4      	; 0x4a0 <CAN_clear_int+0xa>
 49c:	66 0f       	add	r22, r22
 49e:	77 1f       	adc	r23, r23
 4a0:	8a 95       	dec	r24
 4a2:	e2 f7       	brpl	.-8      	; 0x49c <CAN_clear_int+0x6>
 4a4:	40 e0       	ldi	r20, 0x00	; 0
 4a6:	8c e2       	ldi	r24, 0x2C	; 44
 4a8:	0e 94 51 01 	call	0x2a2	; 0x2a2 <CAN_modify>
 4ac:	08 95       	ret

000004ae <main>:
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
 4ae:	9f e0       	ldi	r25, 0x0F	; 15
 4b0:	88 e1       	ldi	r24, 0x18	; 24
 4b2:	0f b6       	in	r0, 0x3f	; 63
 4b4:	f8 94       	cli
 4b6:	a8 95       	wdr
 4b8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
 4bc:	0f be       	out	0x3f, r0	; 63
 4be:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
	
int main(void)
{
   	wdt_enable(WDTO_2S);
	 
   	tx_msg1.ident=0x250; //message 1 ID, supports only standard id's adding extended should be trivial
 4c2:	80 e5       	ldi	r24, 0x50	; 80
 4c4:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <tx_msg1>
 4c8:	e0 e1       	ldi	r30, 0x10	; 16
 4ca:	f1 e0       	ldi	r31, 0x01	; 1
 4cc:	80 81       	ld	r24, Z
 4ce:	88 7f       	andi	r24, 0xF8	; 248
 4d0:	82 60       	ori	r24, 0x02	; 2
 4d2:	80 83       	st	Z, r24
   	tx_msg1.RTR=0;
 4d4:	80 81       	ld	r24, Z
 4d6:	87 7f       	andi	r24, 0xF7	; 247
 4d8:	80 83       	st	Z, r24
   	tx_msg1.DLC=8;
 4da:	80 81       	ld	r24, Z
 4dc:	8f 70       	andi	r24, 0x0F	; 15
 4de:	80 68       	ori	r24, 0x80	; 128
 4e0:	80 83       	st	Z, r24
	   
	tx_msg2.ident=0x251; //message 2 ID
 4e2:	81 e5       	ldi	r24, 0x51	; 81
 4e4:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <tx_msg2>
 4e8:	e6 e0       	ldi	r30, 0x06	; 6
 4ea:	f1 e0       	ldi	r31, 0x01	; 1
 4ec:	80 81       	ld	r24, Z
 4ee:	88 7f       	andi	r24, 0xF8	; 248
 4f0:	82 60       	ori	r24, 0x02	; 2
 4f2:	80 83       	st	Z, r24
	tx_msg2.RTR=0;
 4f4:	80 81       	ld	r24, Z
 4f6:	87 7f       	andi	r24, 0xF7	; 247
 4f8:	80 83       	st	Z, r24
	tx_msg2.DLC=8;
 4fa:	80 81       	ld	r24, Z
 4fc:	8f 70       	andi	r24, 0x0F	; 15
 4fe:	80 68       	ori	r24, 0x80	; 128
 500:	80 83       	st	Z, r24
  
// can transmit interupt timer
	TCCR0A |= (1<<WGM01);
 502:	84 b5       	in	r24, 0x24	; 36
 504:	82 60       	ori	r24, 0x02	; 2
 506:	84 bd       	out	0x24, r24	; 36
	TCCR0B |= (1<<CS02) | (0<<CS01) | (1<<CS00);
 508:	85 b5       	in	r24, 0x25	; 37
 50a:	85 60       	ori	r24, 0x05	; 5
 50c:	85 bd       	out	0x25, r24	; 37
	TIMSK0 |= (1<<OCIE0A); 
 50e:	ee e6       	ldi	r30, 0x6E	; 110
 510:	f0 e0       	ldi	r31, 0x00	; 0
 512:	80 81       	ld	r24, Z
 514:	82 60       	ori	r24, 0x02	; 2
 516:	80 83       	st	Z, r24
	OCR0A=195; 
 518:	83 ec       	ldi	r24, 0xC3	; 195
 51a:	87 bd       	out	0x27, r24	; 39
	
	EIMSK |= (1<<INT1);
 51c:	e9 9a       	sbi	0x1d, 1	; 29
	//EIMSK = 0;
	DDRD=0;
 51e:	1a b8       	out	0x0a, r1	; 10
	PORTD=0;
 520:	1b b8       	out	0x0b, r1	; 11

	DDRD |= (1<<PIND4);
 522:	54 9a       	sbi	0x0a, 4	; 10
	PORTD |= (1<<PORTD0);
 524:	58 9a       	sbi	0x0b, 0	; 11
	   
	   
	SPI_MasterInit();
 526:	0e 94 08 04 	call	0x810	; 0x810 <SPI_MasterInit>
   	CAN_reset();
 52a:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <CAN_reset>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 52e:	8f e4       	ldi	r24, 0x4F	; 79
 530:	93 ec       	ldi	r25, 0xC3	; 195
 532:	01 97       	sbiw	r24, 0x01	; 1
 534:	f1 f7       	brne	.-4      	; 0x532 <main+0x84>
 536:	00 c0       	rjmp	.+0      	; 0x538 <main+0x8a>
 538:	00 00       	nop
	 _delay_ms(10);
	//can init
	CAN_setBaud20(2);
 53a:	82 e0       	ldi	r24, 0x02	; 2
 53c:	0e 94 ae 01 	call	0x35c	; 0x35c <CAN_setBaud20>
	CAN_int_en(0x21);
 540:	81 e2       	ldi	r24, 0x21	; 33
 542:	0e 94 40 02 	call	0x480	; 0x480 <CAN_int_en>
	//CAN_int_en(0x03);
	CAN_mode(0);
 546:	80 e0       	ldi	r24, 0x00	; 0
 548:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <CAN_mode>
	
		if(CAN_check_mode()==0)
 54c:	0e 94 91 01 	call	0x322	; 0x322 <CAN_check_mode>
		{
					//todo: add error handling
		}


	ADS1234_init();
 550:	0e 94 4f 00 	call	0x9e	; 0x9e <ADS1234_init>
	ADS1234_PWR(ADS1234_PWR_ON);
 554:	81 e0       	ldi	r24, 0x01	; 1
 556:	0e 94 58 00 	call	0xb0	; 0xb0 <ADS1234_PWR>
	ADS1234_input_select(ADS1234_AIN1);
 55a:	80 e0       	ldi	r24, 0x00	; 0
 55c:	0e 94 61 00 	call	0xc2	; 0xc2 <ADS1234_input_select>
	ADS1234_Speed(ADS1234_HIGH_SPEED);
 560:	81 e0       	ldi	r24, 0x01	; 1
 562:	0e 94 89 00 	call	0x112	; 0x112 <ADS1234_Speed>
	ADS1234_gain_select(ADS1234_GAIN128);
 566:	83 e0       	ldi	r24, 0x03	; 3
 568:	0e 94 75 00 	call	0xea	; 0xea <ADS1234_gain_select>

	sei();
 56c:	78 94       	sei
		//srednia=temp;
			d0=d0<<8;
			d0=d0>>8;
			// srednia=temp<<8;
			// srednia=srednia>>8;
			tx_msg1.data[0]=d0;
 56e:	0f e0       	ldi	r16, 0x0F	; 15
 570:	11 e0       	ldi	r17, 0x01	; 1
	 ADS1234_input_select(ADS1234_AIN3);
	 while(((DATA_PORT & (1<<DATA_PIN))!=0));
	 d2=ADS1234_read();
	 d2=d2<<8;
	 d2=d2>>8;
		 tx_msg2.data[0]=d2;
 572:	c5 e0       	ldi	r28, 0x05	; 5
 574:	d1 e0       	ldi	r29, 0x01	; 1
 
  
  
    while(1)
    {
       wdt_reset();
 576:	a8 95       	wdr
	   
	 
	 ADS1234_input_select(ADS1234_AIN1);  
 578:	80 e0       	ldi	r24, 0x00	; 0
 57a:	0e 94 61 00 	call	0xc2	; 0xc2 <ADS1234_input_select>
	 while(((DATA_PORT & (1<<DATA_PIN))!=0));
 57e:	32 99       	sbic	0x06, 2	; 6
 580:	fe cf       	rjmp	.-4      	; 0x57e <main+0xd0>
	d0=ADS1234_read();
 582:	0e 94 96 00 	call	0x12c	; 0x12c <ADS1234_read>
		//srednia=temp;
			d0=d0<<8;
 586:	b8 2f       	mov	r27, r24
 588:	a7 2f       	mov	r26, r23
 58a:	96 2f       	mov	r25, r22
 58c:	88 27       	eor	r24, r24
			d0=d0>>8;
 58e:	c9 2e       	mov	r12, r25
 590:	da 2e       	mov	r13, r26
 592:	eb 2e       	mov	r14, r27
 594:	ff 24       	eor	r15, r15
			// srednia=temp<<8;
			// srednia=srednia>>8;
			tx_msg1.data[0]=d0;
 596:	f8 01       	movw	r30, r16
 598:	c2 82       	std	Z+2, r12	; 0x02
			tx_msg1.data[1]=d0>>8;
 59a:	6d 01       	movw	r12, r26
 59c:	ee 24       	eor	r14, r14
 59e:	ff 24       	eor	r15, r15
 5a0:	c3 82       	std	Z+3, r12	; 0x03
			tx_msg1.data[2]=d0>>16;
 5a2:	8b 2f       	mov	r24, r27
 5a4:	99 27       	eor	r25, r25
 5a6:	aa 27       	eor	r26, r26
 5a8:	bb 27       	eor	r27, r27
 5aa:	84 83       	std	Z+4, r24	; 0x04
			tx_msg1.data[3]=d0>>24;
 5ac:	15 82       	std	Z+5, r1	; 0x05
					
	 ADS1234_input_select(ADS1234_AIN2);
 5ae:	82 e0       	ldi	r24, 0x02	; 2
 5b0:	0e 94 61 00 	call	0xc2	; 0xc2 <ADS1234_input_select>
	 while(((DATA_PORT & (1<<DATA_PIN))!=0));
 5b4:	32 99       	sbic	0x06, 2	; 6
 5b6:	fe cf       	rjmp	.-4      	; 0x5b4 <main+0x106>
	 d1=ADS1234_read();
 5b8:	0e 94 96 00 	call	0x12c	; 0x12c <ADS1234_read>
	 //srednia=temp;
	 	 d1=d1<<8;
 5bc:	b8 2f       	mov	r27, r24
 5be:	a7 2f       	mov	r26, r23
 5c0:	96 2f       	mov	r25, r22
 5c2:	88 27       	eor	r24, r24
	 	 d1=d1>>8;
 5c4:	c9 2e       	mov	r12, r25
 5c6:	da 2e       	mov	r13, r26
 5c8:	eb 2e       	mov	r14, r27
 5ca:	ff 24       	eor	r15, r15
		 tx_msg1.data[4]=d1;
 5cc:	f8 01       	movw	r30, r16
 5ce:	c6 82       	std	Z+6, r12	; 0x06
		 tx_msg1.data[5]=d1>>8;
 5d0:	6d 01       	movw	r12, r26
 5d2:	ee 24       	eor	r14, r14
 5d4:	ff 24       	eor	r15, r15
 5d6:	c7 82       	std	Z+7, r12	; 0x07
		 tx_msg1.data[6]=d1>>16;
 5d8:	8b 2f       	mov	r24, r27
 5da:	99 27       	eor	r25, r25
 5dc:	aa 27       	eor	r26, r26
 5de:	bb 27       	eor	r27, r27
 5e0:	80 87       	std	Z+8, r24	; 0x08
		 tx_msg1.data[7]=d1>>24;
 5e2:	11 86       	std	Z+9, r1	; 0x09

	 ADS1234_input_select(ADS1234_AIN3);
 5e4:	81 e0       	ldi	r24, 0x01	; 1
 5e6:	0e 94 61 00 	call	0xc2	; 0xc2 <ADS1234_input_select>
	 while(((DATA_PORT & (1<<DATA_PIN))!=0));
 5ea:	32 99       	sbic	0x06, 2	; 6
 5ec:	fe cf       	rjmp	.-4      	; 0x5ea <main+0x13c>
	 d2=ADS1234_read();
 5ee:	0e 94 96 00 	call	0x12c	; 0x12c <ADS1234_read>
	 d2=d2<<8;
 5f2:	b8 2f       	mov	r27, r24
 5f4:	a7 2f       	mov	r26, r23
 5f6:	96 2f       	mov	r25, r22
 5f8:	88 27       	eor	r24, r24
	 d2=d2>>8;
 5fa:	c9 2e       	mov	r12, r25
 5fc:	da 2e       	mov	r13, r26
 5fe:	eb 2e       	mov	r14, r27
 600:	ff 24       	eor	r15, r15
		 tx_msg2.data[0]=d2;
 602:	ca 82       	std	Y+2, r12	; 0x02
		 tx_msg2.data[1]=d2>>8;
 604:	6d 01       	movw	r12, r26
 606:	ee 24       	eor	r14, r14
 608:	ff 24       	eor	r15, r15
 60a:	cb 82       	std	Y+3, r12	; 0x03
		 tx_msg2.data[2]=d2>>16;
 60c:	8b 2f       	mov	r24, r27
 60e:	99 27       	eor	r25, r25
 610:	aa 27       	eor	r26, r26
 612:	bb 27       	eor	r27, r27
 614:	8c 83       	std	Y+4, r24	; 0x04
		 tx_msg2.data[3]=d2>>24;
 616:	1d 82       	std	Y+5, r1	; 0x05
	 
	 ADS1234_input_select(ADS1234_AIN4);
 618:	83 e0       	ldi	r24, 0x03	; 3
 61a:	0e 94 61 00 	call	0xc2	; 0xc2 <ADS1234_input_select>
	 while(((DATA_PORT & (1<<DATA_PIN))!=0));
 61e:	32 99       	sbic	0x06, 2	; 6
 620:	fe cf       	rjmp	.-4      	; 0x61e <main+0x170>
	 d3=ADS1234_read();
 622:	0e 94 96 00 	call	0x12c	; 0x12c <ADS1234_read>
	 //srednia=temp;
	 	 d3=d3<<8;
 626:	b8 2f       	mov	r27, r24
 628:	a7 2f       	mov	r26, r23
 62a:	96 2f       	mov	r25, r22
 62c:	88 27       	eor	r24, r24
	 	 d3=d3>>8;
 62e:	c9 2e       	mov	r12, r25
 630:	da 2e       	mov	r13, r26
 632:	eb 2e       	mov	r14, r27
 634:	ff 24       	eor	r15, r15
		 tx_msg2.data[4]=d3;
 636:	ce 82       	std	Y+6, r12	; 0x06
		 tx_msg2.data[5]=d3>>8;
 638:	6d 01       	movw	r12, r26
 63a:	ee 24       	eor	r14, r14
 63c:	ff 24       	eor	r15, r15
 63e:	cf 82       	std	Y+7, r12	; 0x07
		 tx_msg2.data[6]=d3>>16;
 640:	8b 2f       	mov	r24, r27
 642:	99 27       	eor	r25, r25
 644:	aa 27       	eor	r26, r26
 646:	bb 27       	eor	r27, r27
 648:	88 87       	std	Y+8, r24	; 0x08
		 tx_msg2.data[7]=d3>>24; 
 64a:	19 86       	std	Y+9, r1	; 0x09
	 
data_rdy=1;
 64c:	81 e0       	ldi	r24, 0x01	; 1
 64e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>

	   
    }
 652:	91 cf       	rjmp	.-222    	; 0x576 <main+0xc8>

00000654 <__vector_2>:




ISR(INT1_vect )
{
 654:	1f 92       	push	r1
 656:	0f 92       	push	r0
 658:	0f b6       	in	r0, 0x3f	; 63
 65a:	0f 92       	push	r0
 65c:	11 24       	eor	r1, r1
 65e:	2f 93       	push	r18
 660:	3f 93       	push	r19
 662:	4f 93       	push	r20
 664:	5f 93       	push	r21
 666:	6f 93       	push	r22
 668:	7f 93       	push	r23
 66a:	8f 93       	push	r24
 66c:	9f 93       	push	r25
 66e:	af 93       	push	r26
 670:	bf 93       	push	r27
 672:	ef 93       	push	r30
 674:	ff 93       	push	r31
	uint8_t flag;

	flag = CAN_get_pint();
 676:	0e 94 45 02 	call	0x48a	; 0x48a <CAN_get_pint>


	switch(flag)
 67a:	90 e0       	ldi	r25, 0x00	; 0
 67c:	fc 01       	movw	r30, r24
 67e:	31 97       	sbiw	r30, 0x01	; 1
 680:	e7 30       	cpi	r30, 0x07	; 7
 682:	f1 05       	cpc	r31, r1
 684:	f8 f4       	brcc	.+62     	; 0x6c4 <__vector_2+0x70>
 686:	ec 5c       	subi	r30, 0xCC	; 204
 688:	ff 4f       	sbci	r31, 0xFF	; 255
 68a:	0c 94 24 04 	jmp	0x848	; 0x848 <__tablejump2__>
	{
		case 1: //error interrupt
		CAN_clear_int(5);
 68e:	85 e0       	ldi	r24, 0x05	; 5
 690:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		break;
 694:	17 c0       	rjmp	.+46     	; 0x6c4 <__vector_2+0x70>
		
		case 2: //wake up
		CAN_clear_int(6);
 696:	86 e0       	ldi	r24, 0x06	; 6
 698:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		
		break;
 69c:	13 c0       	rjmp	.+38     	; 0x6c4 <__vector_2+0x70>
		case 3: //TXB0 empty		
		CAN_clear_int(2);
 69e:	82 e0       	ldi	r24, 0x02	; 2
 6a0:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		
		break;
 6a4:	0f c0       	rjmp	.+30     	; 0x6c4 <__vector_2+0x70>
		case 4: //TXB1 empty
		CAN_clear_int(3);
 6a6:	83 e0       	ldi	r24, 0x03	; 3
 6a8:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		
		break;
 6ac:	0b c0       	rjmp	.+22     	; 0x6c4 <__vector_2+0x70>
		case 5: //TXB2 empty
		CAN_clear_int(4);
 6ae:	84 e0       	ldi	r24, 0x04	; 4
 6b0:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		
		break;
 6b4:	07 c0       	rjmp	.+14     	; 0x6c4 <__vector_2+0x70>
		case 6: //RXB0 full
		CAN_clear_int(0);
 6b6:	80 e0       	ldi	r24, 0x00	; 0
 6b8:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		
		
		break;
 6bc:	03 c0       	rjmp	.+6      	; 0x6c4 <__vector_2+0x70>
		case 7: //RXB1 full
		CAN_clear_int(1);
 6be:	81 e0       	ldi	r24, 0x01	; 1
 6c0:	0e 94 4b 02 	call	0x496	; 0x496 <CAN_clear_int>
		
		break;
	}


}
 6c4:	ff 91       	pop	r31
 6c6:	ef 91       	pop	r30
 6c8:	bf 91       	pop	r27
 6ca:	af 91       	pop	r26
 6cc:	9f 91       	pop	r25
 6ce:	8f 91       	pop	r24
 6d0:	7f 91       	pop	r23
 6d2:	6f 91       	pop	r22
 6d4:	5f 91       	pop	r21
 6d6:	4f 91       	pop	r20
 6d8:	3f 91       	pop	r19
 6da:	2f 91       	pop	r18
 6dc:	0f 90       	pop	r0
 6de:	0f be       	out	0x3f, r0	; 63
 6e0:	0f 90       	pop	r0
 6e2:	1f 90       	pop	r1
 6e4:	18 95       	reti

000006e6 <__vector_14>:



ISR(TIMER0_COMPA_vect ) //10ms
{
 6e6:	1f 92       	push	r1
 6e8:	0f 92       	push	r0
 6ea:	0f b6       	in	r0, 0x3f	; 63
 6ec:	0f 92       	push	r0
 6ee:	11 24       	eor	r1, r1
 6f0:	ef 92       	push	r14
 6f2:	0f 93       	push	r16
 6f4:	1f 93       	push	r17
 6f6:	2f 93       	push	r18
 6f8:	3f 93       	push	r19
 6fa:	4f 93       	push	r20
 6fc:	5f 93       	push	r21
 6fe:	6f 93       	push	r22
 700:	7f 93       	push	r23
 702:	8f 93       	push	r24
 704:	9f 93       	push	r25
 706:	af 93       	push	r26
 708:	bf 93       	push	r27
 70a:	ef 93       	push	r30
 70c:	ff 93       	push	r31

// 	   

if((i>=10) & (data_rdy>0))
 70e:	40 91 01 01 	lds	r20, 0x0101	; 0x800101 <i>
 712:	50 91 02 01 	lds	r21, 0x0102	; 0x800102 <i+0x1>
 716:	60 91 03 01 	lds	r22, 0x0103	; 0x800103 <i+0x2>
 71a:	70 91 04 01 	lds	r23, 0x0104	; 0x800104 <i+0x3>
 71e:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <_edata>
 722:	81 e0       	ldi	r24, 0x01	; 1
 724:	4a 30       	cpi	r20, 0x0A	; 10
 726:	51 05       	cpc	r21, r1
 728:	61 05       	cpc	r22, r1
 72a:	71 05       	cpc	r23, r1
 72c:	08 f4       	brcc	.+2      	; 0x730 <__vector_14+0x4a>
 72e:	80 e0       	ldi	r24, 0x00	; 0
 730:	88 23       	and	r24, r24
 732:	09 f4       	brne	.+2      	; 0x736 <__vector_14+0x50>
 734:	46 c0       	rjmp	.+140    	; 0x7c2 <__vector_14+0xdc>
 736:	81 e0       	ldi	r24, 0x01	; 1
 738:	91 11       	cpse	r25, r1
 73a:	01 c0       	rjmp	.+2      	; 0x73e <__vector_14+0x58>
 73c:	80 e0       	ldi	r24, 0x00	; 0
 73e:	88 23       	and	r24, r24
 740:	09 f4       	brne	.+2      	; 0x744 <__vector_14+0x5e>
 742:	3f c0       	rjmp	.+126    	; 0x7c2 <__vector_14+0xdc>
{
		CAN_TX_Write(tx_msg1,0);
 744:	e1 2c       	mov	r14, r1
 746:	00 91 0f 01 	lds	r16, 0x010F	; 0x80010f <tx_msg1>
 74a:	10 91 10 01 	lds	r17, 0x0110	; 0x800110 <tx_msg1+0x1>
 74e:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <tx_msg1+0x2>
 752:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <tx_msg1+0x3>
 756:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <tx_msg1+0x4>
 75a:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <tx_msg1+0x5>
 75e:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <tx_msg1+0x6>
 762:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <tx_msg1+0x7>
 766:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <tx_msg1+0x8>
 76a:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <tx_msg1+0x9>
 76e:	0e 94 da 01 	call	0x3b4	; 0x3b4 <CAN_TX_Write>
		CAN_RTS(0);
 772:	80 e0       	ldi	r24, 0x00	; 0
 774:	0e 94 2e 02 	call	0x45c	; 0x45c <CAN_RTS>
		CAN_TX_Write(tx_msg2,1);
 778:	ee 24       	eor	r14, r14
 77a:	e3 94       	inc	r14
 77c:	00 91 05 01 	lds	r16, 0x0105	; 0x800105 <tx_msg2>
 780:	10 91 06 01 	lds	r17, 0x0106	; 0x800106 <tx_msg2+0x1>
 784:	20 91 07 01 	lds	r18, 0x0107	; 0x800107 <tx_msg2+0x2>
 788:	30 91 08 01 	lds	r19, 0x0108	; 0x800108 <tx_msg2+0x3>
 78c:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <tx_msg2+0x4>
 790:	50 91 0a 01 	lds	r21, 0x010A	; 0x80010a <tx_msg2+0x5>
 794:	60 91 0b 01 	lds	r22, 0x010B	; 0x80010b <tx_msg2+0x6>
 798:	70 91 0c 01 	lds	r23, 0x010C	; 0x80010c <tx_msg2+0x7>
 79c:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <tx_msg2+0x8>
 7a0:	90 91 0e 01 	lds	r25, 0x010E	; 0x80010e <tx_msg2+0x9>
 7a4:	0e 94 da 01 	call	0x3b4	; 0x3b4 <CAN_TX_Write>
		CAN_RTS(1);
 7a8:	81 e0       	ldi	r24, 0x01	; 1
 7aa:	0e 94 2e 02 	call	0x45c	; 0x45c <CAN_RTS>
i=0;
 7ae:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <i>
 7b2:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <i+0x1>
 7b6:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <i+0x2>
 7ba:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <i+0x3>
data_rdy=0;
 7be:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
}
	   
	i++;
 7c2:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <i>
 7c6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <i+0x1>
 7ca:	a0 91 03 01 	lds	r26, 0x0103	; 0x800103 <i+0x2>
 7ce:	b0 91 04 01 	lds	r27, 0x0104	; 0x800104 <i+0x3>
 7d2:	01 96       	adiw	r24, 0x01	; 1
 7d4:	a1 1d       	adc	r26, r1
 7d6:	b1 1d       	adc	r27, r1
 7d8:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <i>
 7dc:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <i+0x1>
 7e0:	a0 93 03 01 	sts	0x0103, r26	; 0x800103 <i+0x2>
 7e4:	b0 93 04 01 	sts	0x0104, r27	; 0x800104 <i+0x3>

}
 7e8:	ff 91       	pop	r31
 7ea:	ef 91       	pop	r30
 7ec:	bf 91       	pop	r27
 7ee:	af 91       	pop	r26
 7f0:	9f 91       	pop	r25
 7f2:	8f 91       	pop	r24
 7f4:	7f 91       	pop	r23
 7f6:	6f 91       	pop	r22
 7f8:	5f 91       	pop	r21
 7fa:	4f 91       	pop	r20
 7fc:	3f 91       	pop	r19
 7fe:	2f 91       	pop	r18
 800:	1f 91       	pop	r17
 802:	0f 91       	pop	r16
 804:	ef 90       	pop	r14
 806:	0f 90       	pop	r0
 808:	0f be       	out	0x3f, r0	; 63
 80a:	0f 90       	pop	r0
 80c:	1f 90       	pop	r1
 80e:	18 95       	reti

00000810 <SPI_MasterInit>:
#include "../SPI_drv/SPIm328.h"

void SPI_MasterInit( void )
{
	/* Set MOSI and SCK output, all others input */
	DDRB |= (1<<PB3)|(1<<PB5);
 810:	84 b1       	in	r24, 0x04	; 4
 812:	88 62       	ori	r24, 0x28	; 40
 814:	84 b9       	out	0x04, r24	; 4
	/* Enable SPI, Master, set clock rate fck/16 */
	
	SPCR |= (1<<SPE)|(1<<MSTR)|(0<<SPR0);
 816:	8c b5       	in	r24, 0x2c	; 44
 818:	80 65       	ori	r24, 0x50	; 80
 81a:	8c bd       	out	0x2c, r24	; 44
	SPSR |= (1<<SPI2X);
 81c:	8d b5       	in	r24, 0x2d	; 45
 81e:	81 60       	ori	r24, 0x01	; 1
 820:	8d bd       	out	0x2d, r24	; 45
	
	DDRB |=(1<<PB2); // cs wyjscie
 822:	22 9a       	sbi	0x04, 2	; 4
	PORTB|=(1<<PB2); // cs wysoki wysoki
 824:	2a 9a       	sbi	0x05, 2	; 5
 826:	08 95       	ret

00000828 <SPI_MasterTransmit>:
}

void SPI_MasterTransmit( char cData)
{
	/* Start transmission */
	SPDR = cData;
 828:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	
	while(!(SPSR & (1<<SPIF)));
 82a:	0d b4       	in	r0, 0x2d	; 45
 82c:	07 fe       	sbrs	r0, 7
 82e:	fd cf       	rjmp	.-6      	; 0x82a <SPI_MasterTransmit+0x2>
}
 830:	08 95       	ret

00000832 <SPI_MasterRecieve>:

char SPI_MasterRecieve(void)
{
	/*dummy write*/
	SPDR=0xff;
 832:	8f ef       	ldi	r24, 0xFF	; 255
 834:	8e bd       	out	0x2e, r24	; 46
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
 836:	0d b4       	in	r0, 0x2d	; 45
 838:	07 fe       	sbrs	r0, 7
 83a:	fd cf       	rjmp	.-6      	; 0x836 <SPI_MasterRecieve+0x4>
	
	return SPDR;
 83c:	8e b5       	in	r24, 0x2e	; 46
}
 83e:	08 95       	ret

00000840 <SPI_setCS>:

void SPI_setCS(void)
{
	PORTB &= ~(1<<PB2); //cs na zero
 840:	2a 98       	cbi	0x05, 2	; 5
 842:	08 95       	ret

00000844 <SPI_clearCS>:
}

void SPI_clearCS(void)
{
	PORTB |=(1<<PB2);
 844:	2a 9a       	sbi	0x05, 2	; 5
 846:	08 95       	ret

00000848 <__tablejump2__>:
 848:	ee 0f       	add	r30, r30
 84a:	ff 1f       	adc	r31, r31
 84c:	05 90       	lpm	r0, Z+
 84e:	f4 91       	lpm	r31, Z
 850:	e0 2d       	mov	r30, r0
 852:	09 94       	ijmp

00000854 <_exit>:
 854:	f8 94       	cli

00000856 <__stop_program>:
 856:	ff cf       	rjmp	.-2      	; 0x856 <__stop_program>
